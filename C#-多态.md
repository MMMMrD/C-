# C#-多态



## 1.实现方法

(1)==虚方法==	(2)==抽象类==	(3)==接口==



### 1）虚方法

**·实现代码**

>~~~c#
>public class Person
>{
>    public virtual void SayHello() //可被重写的父类源代码
>    {
>        ........;
>    }
>}
>
>public class Son:Person
>{
>    public override void SayHello()
>    {
>        ........;
>    }
>}
>~~~



**·实现原理**

>​		在子类中将父类的代码进行重写，如果一个父类的方法被调用，且这个父类中存着子类对象，子类中还将同名方法重写过，那么这次调用就会直接调用子类==重写后的方法==。
>
>​		若父类中存的是父类对象，那调用该方法的时候还是会调用改写前的方法，同样的，子类若是没有重写该方法，那么调用的时候还是会调用父类的方法。



### 2）抽象类



**·实现代码**

~~~c#
public abstract class Person
{
    public abstract void Test();//抽象方法的声明，要用到abstract
}

public class Son:Person
{
    public override void Test()
    {
        ........;
    }
}
~~~

***注意事项**

>1. 抽象类不能被**实例化**，但是也是包含**构造函数**的
>
>2. 有抽象成员，就要把类写成抽象类，**抽象成员必须在抽象类中**
>
>3. 抽象类中的抽象成员必须标记为 ***abstract*** ，且 **不能有任何实现**
>
>4. 子类继承抽象类之后，必须把父类中所有抽象成员都重写(子类也是抽象类则不用)
>
>5. 抽象类中 **可以包含实例成员**，并且抽象类的实例成员可以不被子列实现
>
>6. 若是父类的抽象方法中有**参数和返回值**，那么继承这个父类的子类在重写方法的时候也必须传入对应的**参数和返回值**



**·==关于虚方法与抽象类的区别==**

​	如上所述，抽象类和虚方法之间存在着很多的共同点，在使用时需要注意以下几点：

>1. 如果父类的方法中**有默认的实现**，并且父类**需要被实例化**，则可以将父类定义为**普通类**
>2. 如果父类的方法中**没有默认的实现**，父类也**不需要被实例化**，则可以将父类定义为**抽象类**



### 3）接口



**·接口的作用**

​	接口是一种==规范==,用于规范继承于接口的类



**·实现代码**

~~~c#
public class class1//声明父类
{
    .......;
}

public interface class2//声明接口
{
    void test();
}

public class class3:class1,class2
{
    .......;
}
~~~

**·==注意事项==**

>1. 接口不能被实例化(不能被 **new**)
>
>2. 接口中的成员只能有方法、自动属性(本质上是 **set** 和 **get** 两个方法)、索引器
>
>3. 接口中的成员不能有访问修饰符，默认为 **public**，也不能拥有方法体
>
>4. 继承接口的子类，必须把接口中的成员==全部实现==(不用加 **override**)
>
>5. 接口与接口之间可以继承，并且可以==多继承==，但接口**不可以继承一个类**
>
>6. 如果一个子类同时继承了一个父类和一个接口，那么**语法上**要将 **类** 写在 **接口** 前面
>
>   >~~~c#
>   >public class Son: Person,interface
>   >{
>   >    .........;
>   >}
>   >~~~





